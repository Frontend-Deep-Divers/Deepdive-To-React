# 5장 리액트와 상태 관리 라이브러리

## 5.1 상태 관리는 왜 필요한가?

- 상태
    - 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값
    - 웹 애플리케이션에는 다음과 같은 것들이 상태로 분류될 수 있다.
        - UI, URL, form, 서버에서 가져온 값
- 리액트 상태 관리의 역사
    - Flux 패턴
        - 기존의 개발에서(2014년 경) 웹 애플리케이션이 비대해지고 상태도 많아짐에 따라 어디서 어떤 일이 일어나서 상태가 변경되었는지 추적하기 어려운 상황이었다.
            
            ![image.png](5%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%84%85%E1%85%A5%E1%84%85%E1%85%B5%20213f78a2bff18019b4bed114c49bf394/image.png)
            
    - 기존 MVC 패턴에서는 뷰가 모델을 변경할 수 있으며 그 반대도 가능한 양방향 데이터 바인딩이었는데, 이는 코드가 복잡해질수록 관리가 어려워진다.
    - 페이스북 팀은 이를 피하기 위해 단방향으로 데이터 흐름을 변경할 것을 제안하는데 이게 Flux 패턴의 시작이다.
        
        ![image.png](5%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%84%85%E1%85%A5%E1%84%85%E1%85%B5%20213f78a2bff18019b4bed114c49bf394/image%201.png)
        
    - 각 용어의 정의
        - 액션 : 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.
        - 디스패처 : 액션을 스토어에 보내는 역할을 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
        - 스토어 : 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다. 액션의 타입에 따라 어떻게 이를 변경할지가 정의돼 있다.
        - 뷰 : 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 또한 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트 하고자 할때는 아래 그림처럼 뷰에서 액션을 호출하는 구조로 구성된다.
            
            ![image.png](5%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%84%85%E1%85%A5%E1%84%85%E1%85%B5%20213f78a2bff18019b4bed114c49bf394/image%202.png)
            
    - 단방향 흐름 방식은 사용자 입력에 따라 데이터를 갱신하고 화면을 어떻게 업데이트해야 하는지 코드로 작성해야 하므로 코드의 양이 많아지고 개발자도 수고로워진다. 허나 데이터의 흐름은 모두 액션이라는 한 방향으로 줄어들므로 데이터의 흐름을 추적하기 쉽고 코드를 이해하기가 수월하다.
    - 리액트 또한 대표적인 단방향 데이터 바인딩을 기반으로 한 라이브러리기에 Flux 패턴과 잘 맞았다.
- 리덕스의 등장
    - 리덕스는 Flux 구조를 구현하기 위해 만들어진 라이브러리중 하나였으며, Elm 아키텍처를 도입했다.
        
        (Elm : 웹 페이지를 선언적으로 작성하기 위한 언어)
        
    - Elm 아키텍처
        - 모델 : 애플리케이션의 상태를 의미한다.
        - 뷰 : 모델을 표현하는 HTML
        - 업데이트 : 모델을 수정하는 방식
    - 하나의 상태 객체를 스토어에 저장해두고, 이 객체를 업데이트 하는 작업을 디스패치해 업데이트를 수행한다. 이러한 작업은 reducer 함수로 발생시킬 수 있는데, 이 함수의 실행은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파하게 된다.
    - 하나의 글로벌 상태 객체를 통해 상태를 하위 컴포넌트에 전파할 수 있기에 prop 내려주기 문제를 해결할 수 있었고 connect만 쓰면 스토어에 바로 접근이 가능한 이점이 있었다.
    - 허나 보일러플레이트 코드가 너무 많았다.
- Context API
    - 리액트 16.3 에서 전역 상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API를 출시
    - props로 상태를 넘겨주지 않더라도 원하는 곳에 Context Provider가 주입하는 상태를 사용할 수 있게 되었다.
- 훅의 탄생과 React Query, SWR
    - 리액트 16.8 버전에서 함수 컴포넌트에 사용할 수 있는 다양한 훅 API가 추가되면서 state를 매우 손쉽게 재사용 가능하도록 만들 수 있었다.
    - React Query와 SWR은 API 호출에 대한 상태를 관리하고 있기에 HTTP 요청에 특화된 상태 관리 라이브러리라 할 수 있다. API 주소가 키로도 사용되며 다른곳에서 동일한 키로 호출하면 재조회 하는 것이 아니라 관리하고 있는 캐시의 값을 활용하기 때문이다.

## 5.2 리액트 훅으로 시작하는 상태 관리

- 가장 기본적인 방법 : useState와 useReducer
    - useState의 등장으로 리액트에서 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 됐다.
    - 리액트의 훅 기반으로 만든 사용자 정의 훅은 함수 컴포넌트라면 어디서든 손쉽게 재사용 가능하다는 장점이 있다.
    - useReduer 또한 usetState와 비슷하게 지역 상태를 관리할 수 있는 훅이다.
    - 훅을 사용할 때마다 컴포넌트별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가지게 되어 컴포넌트별로 상태의 파편화를 만들어버릴 수 있다.
    - 기본적으로 useState를 기반으로 한 상태를 지역 상태라고 하며, 이는 해당 컴포넌트 내에서만 유효하다는 한계가 있다.
- useState의 상태를 바깥으로 분리하기
    - 함수 외부에서 상태를 참조하고 이를 통해 렌더링까지 자연스럽게 일어나려면 다음과 같은 조건을 만족해야 한다.
        - 꼭 window나 global에 있어야 할 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸수 있어야 한다.
        - 이 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고 상태가 변화될 때마다 리렌더링이 일어나서 컴포넌트를 최신 상태값 기준으로 렌더링해야 한다. 이 상태 감지는 상태를 변경시키는 컴포넌트 뿐만 아니라 이 상태를 참조하는 모든 컴포넌트에서 동일하게 작동해야 한다.
        - 상태가 원시값이 아닌 객체인 경우에 그 객체에 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해서는 안된다.
    - useSubscription 훅을 사용하면 외부에 있는 데이터를 가져와서 사용하고 리렌더링까지 가능하다.
- Recoil
    - RecoilRoot를 최상위 컴포넌트에 선언하여 Recoil에서 생성되는 상태값을 저장하기 위한 스토어를 생성하자.
    - Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장된다.
    - 스토어의 상태값에 접근할 수 있는 함수들이 있으며 이 함수를 활용해 상태값에 접근하거나 상태값을 변경할 수 있다.
    - 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알린다.
    - atom
        - 상태를 나타내는 Recoil의 최소 단위
        - key값을 필수로 가지며 다른 atom과 구별하는 식별자가 되는 필수 값이다.
    - useRecoilValue
        - atom의 값을 읽어오는 훅
        - 현재 Recoil이 가지고 있는 상태값을 가지고 있는 클래스인 loadable을 반환하고 이 값을 이전값과 비교해 ref에 매번 저장한다.
        - useEffect를 통해 recoilValue가 변경됐을 때 forceUpdate를 호출해 렌더링을 강제로 일으킨다.
    - useRecoilState
        - atom의 값을 가져오고 이 값을 변경할 수도 있는 훅
        - useState와 흡사한 구조를 가진다.
    - 특징
        - 페이스북 팀에서 주도적으로 개발하고 있기에 리액트에서 새롭게 만들어지는 기능을 잘 지원한다.
        - 허나 아직 정식버전이 출시가 되지 않았다…
- Jotai
    - bottom-up 접근법으로 작은 단위의 상태를 위로 전파할 수 있는 구조를 가지고 있다.
    - 리액트 Context의 문제점인 불필요한 리렌더링이 일어난다는 문제를 해결하고자 설계돼있다.
    - atom
        - Recoil과 마찬가지로 최소 단위의 상태를 의미한다.
        - 허나 atom하나로 파생된 상태까지 만들 수 있다.
    - useAtomValue
        - atom의 값을 가져오는 훅
    - useAtom
        - atom을 수정할 수 있는 기능을 제공한다.
        - useState와 동일한 형태의 배열을 반환한다.
    - 특징
        - atom개념을 도입하면서도 API가 간결하다. 키를 추상화해서 사용자가 키를 관리할 필요가 없기 때문.
- Zustand
    - 하나의 스토어를 중앙 집중형으로 활용해 스토어 내부에서 상태를 관리하고 있다.
    - 특징
        - 몇줄의 코드만으로 빠르게 스토어를 만들고 사용할 수 있다.
        - API가 복잡하지 않고 사용이 간단해 쉽게 접근할 수 있다.