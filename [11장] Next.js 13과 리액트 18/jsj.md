# 11장 Next.js 13과 리액트 18

## 11.1 app 디렉터리의 등장

- Next.js 12 버전까지는 무언가 페이지 공통 레이아웃을 유지할 수 있는 방법은 _app이 유일했다. 허나 이 방식은 _app 에서밖에 할 수 없어 제한적이고, 각 페이지별로 서로 다른 레이아웃을 유지할 수 있는 여지도 부족하다.
- 이러한 레이아웃의 한계를 극복하기 위해 나온 것이 Next.js의 app 레이아웃이다.
- 라우팅
    - /pages 로 정의하던 라우팅 방식이 /app 디렉터리로 이동했다.
    - Next.js 13의 app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다.
    - app 디렉터리 내부의 폴더명이 라우팅이 된다.
    - 루트에는 단 하나의 layout을 만들 수 있으며 이는 모든 페이지에 영향을 미치는 공통 레이아웃이다.
    - 페이지 하위에 추가되는 layout은 해당 주소 하위에만 적용된다.
    - error.js 는 해당 라우팅 영역에서 사용하는 공통 에러 컴포넌트다. 이를 통해 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.
    - not-found는 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용된다.
    - loading은 리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있다.

## 11.2 리액트 서버 컴포넌트

- 기존의 리액트의 경우, 웹 사이트를 방문하면 리액트 실행에 필요한 코드를 다운로드하고 리액트 컴포넌트 트리를 만든 다음, DOM에 렌더링한다.
- 서버 사이드 렌더링의 경우, 미리 서버에서 DOM을 만들어 오고 클라이언트에서 이 DOM을 가지고 하이드레이션을 진행한다.
- 이런 구조의 경우 몇가지 한계점이 있다.
    - 자바 스크립트 번들 크기가 0인 컴포넌트를 만들 수 있다.
    - 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
    - 자동 코드 분할이 불가능하다.
    - 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
    - 추상화에 드는 비용이 증가한다.
- 서버 사이드 렌더링은 정적 콘텐츠를 빠르게 제공하고, 서버에 있는 데이터에 손쉽게 제공할 수 있는 반면 사용자 인터랙션에 따른 다양한 사용자 경험을 제공하기 어렵다.
- 클라이언트 사이드 렌더링은 사용자의 인터렉션에 따라 다양한 것들을 제공할 수 있지만 서버에 비해 느리고 데이터를 가져오는 것도 어렵다.
- 리액트 서버 컴포넌트를 통해 이 두 구조의 장점을 모두 취할 수 있다.
- 서버 컴포넌트 : 하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법. 서버에서 할 수 있는 일은 서버에서 처리하게 두고 서버가 할 수 있는 나머지 작업은 클라이언트인 브라우저에서 수행된다.
- 컴포넌트들의 차이와 제약 사항
    - 서버 컴포넌트
        - 요청이 오면 그 순간 서버에서 딱 한번 실행될 뿐이므로 상태를 가질 수 없다. 따라서 리액트에서 상태를 가질 수 없는 useState, useReducer 등의 훅을 사용할 수 없다.
        - 렌더링 생명 주기도 사용할 수 없다. 한번 렌더링되면 그걸로 끝이기 때문이다. 따라서 useEffect, useLayoutEffect를 사용할 수 없다.
        - 앞의 두가지 제약사항으로 인해 effect나 state에 의존하는 사용자 정의훅 또한 사용할 수 없다. 다만 effect나 state에 의존하지 않고 서버에서 제공할 수 있는 기능만 사용하는 훅이라면 충분히 사용 가능하다.
        - 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 DOM API를 쓰거나 window, document 등에 접근할 수 없다.
        - 데이터베이스, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async/await 으로 접근할 수 있다. 컴포넌트 자체가 async 한것이 가능하다.
        - 다른 서버 컴포넌트를 렌더링하거나 div, span, p 같은 요소를 렌더링하거나, 혹은 클라이언트 컴포넌트를 렌더링 할 수 있다.
    - 클라이언트 컴포넌트
        - 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없다.
        - 허나 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다.
    - 공용 컴포넌트
        - 서버와 클라이언트 모두에서 사용할 수 있다. 서버 컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트가 된다.
- 서버 컴포넌트의 동작 방식
    - 서버가 렌더링 요청을 받는다. 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다. 즉 루트에 있는 컴포넌트는 항상 서버 컴포넌트다.
    - 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화한다. 이때 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스 홀더 형식으로 비워두고 나타낸다.
    - 브라우저는 이 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행한다.
    - 브라우저가 리액트 컴포넌트 트리를 구성한다. 브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어 나간다. 클라이언트 컴포넌트를 받았다면 클라이언트에서 렌더링을 진행하고, 서버에서 만들어진 결과물을 받았다면 이 정보를 기반으로 리액트 트리를 그대로 만들어 트리를 렌더링해 브라우저의 DOM에 커밋한다.
    

## 11.3 Next.js 에서의 리액트 서버 컴포넌트

- 대부분 리액트 서버 컴포넌트에서 제공하는 내용과 별다른 차이가 없는데, Next.js 에서 서버 컴포넌트를 도입하면서 달라진 부분이 몇가지 있다.
- 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps 의 삭제
    - 과거 Next.js 의 서버 사이드 렌더링과 정적 페이지 제공을 위해 이용되던 요소들이 /app 디렉터리 내부에서는 삭제됐다. 그 대신 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄진다.
- 정적 렌더링과 동적 렌더링
    - Next.js 13에서는 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용할 수 있게끔 해두었고, 동적인 라우팅에 대해서는 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경했다.
- 캐시와 mutating, 그리고 revalidating
    - Next.js 는 fetch의 기본 작동을 재정의하고 이를 바탕으로 해당 데이터를 유효 시간을 정해두고 이 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링하는 것이 가능하다.
    - 캐시와 갱신이 이뤄지는 과정은 다음과 같다.
        - 최초로 해당 라우트로 요청이 올 때는 미리 정적으로 캐시해둔 데이터를 보여준다.
        - 이 캐시된 초기 요청은 revalidate에 선언된 값만큼 유지된다.
        - 만약 해당 시간이 지나도 일단은 캐시된 데이터를 보여준다.
        - Next.js 는 캐시된 데이터를 보여주는 한편, 시간이 경과했으므로 백그라운드에서 다시 데이터를 불러온다.
        - 위의 작업이 성공적으로 끝나면 캐시된 데이터를 갱신하고, 그렇지 않다면 과거 데이터를 보여준다.
- 스트리밍을 활용한 점진적인 페이지 불러오기
    - 과거의 서버 사이드 렌더링의 경우 요청받은 페이지를 모두 렌더링해서 내려주기 전까지는 사용자에게 아무것도 보여주지 않았다. 이를 해결하기 위해 하나의 페이지가 다 완성될 때까지 기다리는 것이 아니라 HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 스트리밍이 도입됐다.
    - 스트리밍 활용법
        - 경로에 loading.tsx 배치
        - Suspense 배치
    

## 11.4 웹팩의 대항마 터보 팩의 등장(beta)

- 터보팩은 웹팩 대비 최대 700배, Vite 대비 최대 10배 빠르다고 하지만 현재(책 기준 13.1.x)으로는 베타다..

## 11.5 서버 액션(alpha)

- API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청등을 수행할 수 있는 기능
- 특정 함수 실행 그 자체만을 서버에서 수행할 수 있다는 장점이 있다.
- 서버 액션을 만드려면 함수 내부 또는 파일 상단에 클라이언트 선언과 비슷하게 “use server” 지시자를 선언해야 하며 그 함수는 반드시 async 여야 한다.
- form의 action
    - form을 서버 액션과 함께 사용하면 form을 기반으로 한 데이터 추가 및 수정 요청을 좀 더 자연스럽게 수행할 수 있다.
    - Next.js 에서 관리하는 캐시 또한 효과적으로 초기화 할 수 있다.
- 이외에도 input의 submit이나 image의 formAction, startTransition과의 연동 등에 서버 액션을 도입할 수 있다.
- 서버 액션 사용시 주의점
    - 서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없다.
    - 서버 액션을 import 한것 뿐만 아니라 props형태로 서버 액션을 클라이언트 컴포넌트에 넘기는 것 또한 가능하다.