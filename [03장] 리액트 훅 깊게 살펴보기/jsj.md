# 3장 리액트 훅 깊게 살펴보기

## 3.1 리액트의 모든 훅 파헤치기

- useState
    - 함수 컴포넌트 내부에서 상태를 정의하고 상태를 관리할 수 있게 해주는 훅
    
    ```jsx
    const [state, setState] = useState(initState)
    ```
    
    - 인수로 사용할 state의 초기값을 넘겨준다. 아무런 값을 넘겨주지 않으면 undefined로 초기값을 설정한다.
    - useState 훅의 반환 값은 배열이며 첫번째 원소로 state 값 자체를 사용할 수 있고, 두번째 원소인 setState 함수를 사용해 해당 state의 값을 변경할 수 있다.
    - 내부에서 클로저를 통해 함수 컴포넌트의 실행이 끝나도 state 값을 기억해 유지하고 사용한다.
    
    > ❓ 게으른 초기화
    useState에 변수 대신 함수를 넘겨 사용하는 것을 의미하며, 초기값이 복잡하거나 무거운 연산을 포함하고 있을 때 주로 사용된다.
    넘겨진 함수는 최초 렌더링시에만 사용된다.
    > 

- useEffect
    - 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘
    
    ```jsx
    useEffect(()=>{
    	//do something
    	}, [props, state])
    ```
    
    - 첫번째 인수로는 실행할 부수 효과가 포함된 함수를, 두번째 인수로는 의존성 배열을 전달한다.
    - 의존성 배열이 변경될때마다 useEffect의 첫번째 인수인 콜백을 실행한다.
    - 특별한 기는을 통해 값의 변화를 관찰하는 것이 아니고 렌더링할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른게 하나라도 있으면 부수 효과를 실행하는 함수다.
    - 클린업 함수
        - useEffect 내에서 반환되는 함수로 이벤트를 등록하고 지울 때 사용한다.
        - 이전 state를 참조해 실행되며 새로운 값을 기반으로 렌더링 된 뒤에 실행되지만 이 변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언했던 이전 값을 보고 실행된다.
        - useEffect에 이벤트를 추가하는 경우 클린업 함수에서 지워야 하는데, 이는 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행하기 때문이다. 따라서 이벤트를 추가하기 전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가하여 이벤트 핸들러가 무한히 추가되는 것을 방지할 수 있다.
    - 의존성 배열
        - 의존성 배열은 보통 빈 배열을 두거나, 아무런 값도 넘기지 않거나 사용자가 직접 원하는 값을 넣어줄 수 있다.
        - 빈배열을 둘 경우, useEffect는 비교할 의존성이 없다고 판단해 최초 렌더링 직후에 실행된 다음부터는 더 이상 실행되지 않는다.
        - 아무런 값도 넘기지 않는 경우, 이때는 의존성을 비교할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행된다.
    - 구현
        - 의존성 배열의 이전값과 현재값의 얕은 비교를 통해 하나라도 변경 사항이 있으면 콜백으로 선언한 부수 효과를 실행한다.
    - 주의점
        - eslint-diable-line react-hooks/exhaustive-deps 주석은 자제하라
            - 이 규칙들은 useEffect 인수 내부에서 사용하는 값 중 의존성 배열에 포함돼 있지 않은 값이 있을 때 경고를 발생시키는데, 해당 주석으로 경고들을 무시하게 되면 대부분의 경우에 의도치 못한 버그를 만들 가능성이 커진다.
        - useEffect의 첫번째 인수에 함수명을 부여하라
            - useEffect의 코드가 복잡하고 많아질수록 코드 파악이 어려워지기에 useEffect의 인수를 익명이 아닌 적절한 이름을 가진 기명 함수로 작성하자.
        - 거대한 useEffect를 만들지 마라
            - useEffect의 부수효과의 크기가 커질수록 애플리케이션 성능에 악영향을 미친다.
        - 불필요한 외부 함수를 만들지 마라
            - useEffect가 실행하는 콜백 또한 불필요하게 존재해서는 안된다.
- useMemo
    - 비용이 큰 연산에 대한 결과를 저장해두고 이 저장된 값을 반환하는 훅
    - 첫번째 인수로는 어떠한 값을 반환하는 생성 함수를, 두번째 인수로는 해당 함수가 의존하는 값의 배열을 전달한다.
    - useMemo는 렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면 함수를 재실행하지 않고 이전에 기억해 둔 해당 값을 반환하고, 의존성 배열의 값이 변경됐다면 첫번째 인수의 함수를 실행한 후에 그 값을 반환하고 그 값을 다시 기억해둔다. 이는 단순 값뿐만 아니라 컴포넌트도 가능하다.
- useCallback
    - 인수로 넘겨받은 콜백 자체를 기억한다. 특정 함수를 새로 만들지 않고 다시 재사용한다는 의미다.
    - 첫번째 인수로 함수를, 두번째 인수로 의존성 배열을 집어 넣으면 의존성 배열이 변경되지 않는 한, 함수를 재생성하지 않는다.
    - useMemo와의 차이는 메모이제이션을 하는 대상이 변수냐 함수냐일 뿐이다. 내부의 구현은 거의 비슷하다.
- useRef
    - useState처럼 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다.
    - 허나 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있으며, useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다.
    - 원하는 시점의 값을 렌더링에 영향을 미치지 않고 보관해두고 싶다면 사용해보자.
- useContext
    - Context란?
        - 명시적인 props 전달 없이도 선언한 하위 컴포넌트에 모두에서 자유롭게 원하는 값을 사용할수 있게한다.
        
        ```jsx
        const Context = createContext<{hello: string} | undefined>(undefined)
        
        function ParentComponent(){
        	return(
        		<>
        			<Context.Provider vale={{hello:'react'}}>
        				<ChildComponent />
        			</Context.Provider>
        		</>
        	)
        }
        ```
        
    - 상위 컴포넌트에서 만들어진 Context를 함수 컴포넌트에서 사용할 수 있도록 만들어진 훅으로 상위 컴포넌트 어딘가에서 선언된 `<Context.Provider />` 에서 제공한 값을 사용할 수 있게 된다.
    - 주의할점
        - 함수 컴포넌트 내부에서 사용할 때는 컴포넌트 재활용이 어려워진다. useContext가 선언되어 있으면 Provider에 의존성을 가지고 있는 셈이므로 아무데서나 재사용이 어려워지기 때문이다.
        - useContext를 사용하는 컴포넌트를 최대한 작게 하거나 혹은 재사용되지 않을 만한 컴포넌트에서 사용해야한다.
        - useContext는 상태를 주입해주는 리액트의 API일 뿐, 상태 관리를 위한 것은 아니다.
- useReducer
    - useState와 비슷한 형태를 띠지만 좀 더 복잡한 상태 값을 미리 정의해 놓은 시나리오에 따라 관리할 수 있다.
    - 반환 값은 useState와 동일하게 길이가 2인 배열이다.
        - state : 현재 useReducer가 가지고 있는 값을 의미한다. useState와 마찬가지로 배열을 반환하는데, 동일하게 첫번째 요소가 이 값이다.
        - dispatcher : state를 업데이트하는 함수로, useReducer가 반환하는 배열의 두번째 요소다. 여기서는 단순히 값을 넘겨주는 것이 아닌 action을 넘겨준다.
    - useState의 인수와 달리 2개에서 3개의 인수를 필요로 한다.
        - reducer : useReducer의 기본 action을 정의하는 함수로 이 reducer는 useReducer의 첫번째 인수로 넘겨줘야 한다.
        - initialState : 두번째 인수로, useReducer의 초깃값을 의미한다.
        - init : useState의 인수로 함수를 넘겨줄 때처럼 초기값을 지연해서 생성시키고 싶을 때 사용하는 함수다. 이 함수는 필수값이 아니며, 만약 여기에 인수로 넘겨주는 함수가 존재한다면 useState와 동일하게 게으른 초기화가 일어나며 initialState를 인수로 init 함수가 실행된다.
    - 복잡한 형태의 state를 사전에 정의된 dispatcher로만 수정할 수 있게 만들어 줌으로써 state 값에 대한 접근은 컴포넌트에서만 가능하게 하고, 이를 업데이트하는 방법에 대한 상세 정의는 컴포넌트 밖에다 둔 다음, state의 업데이트를 미리 정의해 둔 dispatcher로만 제한한다.
    - state값을 변경하는 시나리오를 제한적으로 두고 이에 대한 변경을 빠르게 확인할 수 있게끔 하는 것이 목적이다.
    - useState와 비슷하게 클로저를 활용하여 구현한다.
- useImperativeHandle
    - forwardRef
        - ref를 상위 컴포넌트에서 하위 컴포넌트로 전달할 때, ref를 props로 전달하는 용도다.
    - useImperativeHandle은 부모에게서 넘겨받은 ref를 원하는대로 수정할 수 있는 훅이다.
    - ref의 값에 원하는 값이나 액션을 정의하여 부모 컴포넌트에서 노출되는 값을 원하는대로 바꿀 수 있다.
- useLayoutEffect
    - useEffect와 시그니처(훅의 형태나 사용예제)가 동일하나 모든 DOM의 변경 후에 동기적으로 발생한다.
    - 실행 순서
        - 리액트가 DOM을 업데이트
        - useLayoutEffect를 실행
        - 브라우저에 변경 사항을 반영
        - useEffect를 실행
    - DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때 (애니메이션이나 스크롤 위치 제어 등)사용하면 더 자연스러운 사용자 경험을 제공할 수 도 있다.
- useDebugValue
    - 디버깅하고 싶은 정보를 이 훅에 사용하면 리액트 개발자 도구에서 볼 수 있다.
    - 사용자 정의 훅 내부의 내용에 대한 정보를 남길 수 있는 훅이며 두번째 인수로 포매팅 함수를 전달하면 이에 대한 값이 변경됐을 때만 호출되어 포매팅된 값을 노출한다.
    - 오직 다른 훅 내부에서만 실행할 수 있음에 주의하자.
- 훅의 규칙
    - 최상위에서만 훅을 호출해야한다. 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다. 이 규칙을 따라야만 컴포넌트가 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.
    - 훅을 호출할 수 있는 것은 리액트 함수 컴포넌트, 혹은 사용자 정의 훅의 두가지 경우 뿐이다. 일반 자바스크립트 함수에서는 훅을 사용할 수 없다.
- 훅은 절대 조건문, 반복문 등에 의해 리액트에서 예측 불가능한 순서로 실행되게 해서는 안된다!