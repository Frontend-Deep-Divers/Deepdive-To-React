# 2장

## 2.1 JSX란?

- 리액트가 등장하면서 생겨난 새로운 내장형 구문이지만, 리액트에서만 사용하라는 법은 없다.
- 페이스북에서 독자적으로 개발했기에 ECMAScript같은 자바스크립트 표준의 일부는 아니고, 자바 스크립트 엔진이나 브라우저에 의해서 실행되거나 표현되도록 만들어진 구문 또한 아니다.
- JSX의 설계 목적은 JSX내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해 두고, 이를 트랜스 파일을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경하는 것이다.
- 자바 스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는데 많은 도움을 준다.
- JSX의 정의
    - JSX는 기본적으로 JSXElement, JSXAttributes, JSXChildren, JSXStrings 라는 4가지 컴포넌트 기반으로 구성돼 있다.
    - JSXElement
        - JSX를 구성하는 가장 기본 요소로, HTML의 요소와 비슷한 역할을 한다. JSXElement가 되기 위해서는 다음과 같은 형태 중 하나여야 한다.
            - JSXOpeningElement : 일반적으로 볼 수 있는 요소로 JSXOpeningElement로 시작했다면 후술할 JSXClosingElement가 동일한 요소로 같은 단계에서 선언돼 있어야 올바른 JSX 문법으로 간주된다.
            - JSXClosingElement : JSXOpeningElement가 종료됐음을 알리는 요소로, 반드시 JSXOpeningElement와 쌍으로 사용돼야 한다.
            - JSXSelfClosingElement : 요소가 시작되고, 스스로 종료되는 형태를 의미한다. `<script/>` 와 동일한 모습을 띠고 있다. 이는 내부적으로 자식을 포함할 수 없는 형태를 의미한다.
            - JSXFragment : 아무런 요소가 없는 형태로, JSXSelfClosingElement 형태를 띌 수는 없다. `</>`는 불가능하나 `<></>` 는 가능하다.
        - JSXElementName
            - JSXElement의 요소 이름으로 쓸 수 있는 것을 의미한다. 이름으로 ㅆ르 수 있는 것은 다음과 같다.
                - JSXIdentifier : JSX 내부에서 사용할 수 있는 식별자로 자바 스크립트 식별자 규칙과 동일하다.
                - JSXNamespaceName : `JSXIdentifier:JSXIdentifier` 의 조합으로 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급되며 한개씩만 묶을 수 있다.
                - JSXMemberExpression : `JSXIdentifier.JSXIdentifier` 의 조합으로 `:` 로 묶는 namespaceName과 다르게 여러개 이어서도 가능하다.
    - JSXAttributes
        - JSXElement에 부여할 수 있는 속성을 의미하며 단순히 속성을 의미하기에 모든 경우에서 필수 값이 아니고, 존재하지 않아도 에러가 나지 않는다.
        - JSXSpreadAttributes : 자바 스크립트의 전개 연산자와 동일한 역할을 한다.
        - JSXAttribute : 속성을 나타내는 키와 값으로 짝을 이루어서 표현한다. 키는 JSXAttributeName, 값은 JSXAttributeValue로 불린다.
    - JSXChildren
        - JSXElement의 자식 값을 나타낸다. JSX는 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문
        - JSXChild : JSXChildren을 이루는 기본단위며 JSXChildren은 JSXChild를 0개 이상 가질 수 있다.
    - JSXStrings
        - HTML에서 사용 가능한 문자열은 모두 JSXStrings에서도 가능하다. “큰따옴표로 구성된 문자열”, ‘작은 따옴표로 구성된 문자열’ 혹은 JSXText를 정의된 문자열이라 하며 이들을 HTML과 JSX 사이에서 자유롭게 사용이 가능하다.
        - 이스케이프 문자 (`\` )의 경우만 자바 스크립트에서 따로 처리를 해주자.
- JSX 예제
    
    ```jsx
    const ComponentA = <A>안녕하세요.</A>
    ```
    
- JSX는 어떻게 자바 스크립트에서 변환될까?
    - `@babel/plugin-transform-react-jsx` 플러그인은 JSX구문을 자바스크립트가 이해할 수 있는 형태로 변환한다.
    - JSX코드와 변환한 결과는 다음과 같다.
        
        ```jsx
        //JSX 코드
        const ComponentA = <A required={true}>Hello World</A>
        
        const ComponentB = <>Hello World</>
        
        const ComponentC = (
        	<div>
        		<span>hello world</span>
        	</div>
        )
        
        //변환한 결과
        'use strict'
        
        var ComponentA = React.createElement(
        	A,
        	{
        		required : true,
        	},
        	'Hello World',
        )
        var ComponentB = React.createElement(React.Fragment, null, 'Hello World')
        var ComponentC = React.createElement(
        	'div',
        	null,
        	React.createElement('span', null, 'hello world'),
        )
        ```
        
    - JSXElement를 첫 번째 인수로 선언해 요소를 정의하며 옵셔널인 JSXChildren, JSXAttributes, JSXString는 이후 인수로 넘겨주어 처리한다.
    - JSX 반환값은 결국 React.createElement로 귀결된다.
- JSX는 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있지만 코드의 가독성을 해칠 수 있다.

## 2.2 가상 DOM과 리액트 파이버

- DOM과 브라우저 렌더링 과정
    - DOM은 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여 줄지에 대한 정보를 담고 있다.
    - 브라우저가 웹 사이트 접근 요청을 받고 화면을 그리는 과정
        - 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드 한다.
        - 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
        - 위 과정에서 CSS 파일을 만나면 해당 CSS파일도 다운로드한다.
        - 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)도 만든다.
        - 브라우저는 위에서 만든 DOM 노드를 순회하는데 이때 모든 노드를 방문하는 것이 아니라 사용자 눈에 보이는 노드만 방문한다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서이다.
        - 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 2가지로 나눌 수 있다.
            - 레이아웃 : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
            - 페인팅 : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정
- 가상 DOM의 탄생 배경
    - 렌더링이 완료된 이후에도 사용자의 인터렉션으로 레이아웃이 일어나는 경우 렌더링 이후 추가 렌더링 작업이 발생하면서 브라우저와 사용자에게 추가적인 비용이 발생한다.
    - SPA의 경우 하나의 페이지에서 계속해서 요소의 위치를 재계산하기에 DOM을 관리하는 과정에서 부담해야할 비용이 커진다.
    - 이러한 문제를 해결하기 위해 탄생한 것이 바로 가상 DOM이다. 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM을 의미한다.
    - 가상 DOM은 웹 페이지가 표시해야할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다. 이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한번 거쳐 실제로는 여러번 발생했을 렌더링 과정을 최소화하고, 브라우저와 개발자의 부담을 덜 수 있다.
- 가상 DOM을 위한 아키텍처, 리액트 파이버
    - 리액트 파이버 : 리액트에서 관리하는 평범한 자바스크립트 객체로 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하고 차이가 나는 부분을 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.
    - 리액트 파이버의 목표는 리액트 웹 어플리케이션에서 발생하는 애니메이션, 레이아웃, 사용자 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다. 이를 위해 파이버를 다음과 같은 일을 할 수 있다.
        - 작업을 작은 단위로 분할하고 쪼갠 다음, 우선 순위를 매긴다.
        - 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
        - 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.
    - 또한 이 모든 과정이 비동기로 일어난다는 것이다. 기존의 리액트 조정 알고리즘은 스택 알고리즘으로 자바 스크립트의 특징인 싱글 스레드와 맞물려 동기적으로 작업이 이뤄졌고 이는 매우 비효율적이었다.
    - 기존의 비효율성을 타파하기 위해 파이버의 경우 하나의 작업 단위로 구성돼 있으며 리액트는 이러한 작업 단위를 하나씩 처리하고 finishedWork() 라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어낸다.
        - 랜더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
        - 커밋 단계에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork() 가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수 도 없다.
    - 파이버는 리액트 요소와 유사하다고 느낄 수 있지만 리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되나 파이버는 가급적이면 재사용된다.
    - 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다. 리액트가 파이버를 처리할 때마다 이러한 작업을 직접 바로 처리하기도 하고 스케줄링하기도 한다. 즉, 우선순위가 높은 작업은 가능한 빠르게 처리하거나 낮은 작업을 연기시키는 등 유연하게 처리된다.
- 리액트 파이버 트리
    - 파이버 트리는 리액트 내부에서 2개가 존재한다. 현재 모습을 담은 파이버 트리, 작업 중인 상태를 나타내는 workInProgress 트리다.
    - 더블 버퍼링 : 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버린다. + 그래픽을 통해 화면에 표시되는 것을 그릴때 내부적 처리를 거치는 과정에서 사용자에게 미처 다 그리지 못한 모습을 보는 경우가 발생하는 것을 막고자 보이지 않는 곳에서 그 다음으로 그려야할 그림을 미리 그린 다음, 이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법을 의미한다.
    - 먼저 현재 UI 렌더링을 위해 존재하는 트리인 current를 기준으로 모든 작업이 시작된다. 만약 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 workInProgress 트리를 빌드하기 시작한다. 이 workInProgress 트리를 빌드하는 작업이 끝나면 다음 렌더링에 이 트리를 사용하며 이 workInProgress 트리가 UI에 최종적으로 렌더링되어 반영이 완료되면 current가 이 workInProgress로 변경된다.
- 파이버의 작업 순서
    - 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
    - 위에서 작업이 끝난다면 그 다음 completeWork() 함수를 실행해 파이버 작업을 완료한다.
    - 형제가 있다면 형제로 넘어간다.
    - 2,3번이 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.
- 파이버와 가상 DOM
    - 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며, 이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄진다.
    - 이러한 비동기 작업과 달리, 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로 이러한 작업을 가상에서 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

## 2.3 클래스 컴포넌트와 함수 컴포넌트

- 클래스 컴포넌트의 생명주기 메서드
    - 생명주기 메서드가 실행되는 시점
        - 마운트 : 컴포넌트가 마운팅되는 시점
        - 업데이트 : 이미 생성된 컴포넌트의 내용이 변경되는 시점
        - 언마운트 : 컴포넌트가 더 이상 존재하지 않는 시점
    - render()
        - 리액트 클래스 컴포넌트의 유일한 필수 값으로 항상 쓰인다. 컴포넌트가 UI를 렌더링하기 위해서 쓰인다. 이 렌더링은 마운트와 업데이트 과정에서 일어난다.
        - 이 함수는 항상 순수해야 하며 부수효과가 없어야 한다. (같은 입력값이 들어가면 같은 결과물을 반환) 따라서, render 내부에서 state를 직접 업데이트하는 this.setState를 호출해서는 안된다.
    - componentDidMount()
        - 클래스 컴포넌트가 마운트되고 준비가 됐다면 그다음으로 호출되는 생명주기 메서드로 컴포넌트가 마운트되고 준비되는 즉시 실행된다.
        - 이 함수 내부에서는 this.setState()로 state값을 변경하는 것이 가능하다. this.setState()를 호출했다면 state가 변경되고, 즉시 렌더링을 시도하는데, 이 작업은 브라우저가 실제로 UI를 업데이트하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다.
    - componentDidUpdate()
        - 컴포넌트 업데이트가 일어난 이후 바로 실행된다. 일반적으로 state나 props의 변화에 따라 DOM을 업데이트하는 등에 쓰인다.
    - componentWillUnmount()
        - 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다. 메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치다.
    - shouldComponentUpdate()
        - state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶을 때 사용하는 메서드
        - this.setState가 호출되면 컴포넌트는 리렌더링을 일으킨다. 그러나 이 생명주기 메서드를 활용하면 컴포넌트에 영향을 받지 않는 변화에 대해 정의할 수 있다.
    - static getDerivedStateFromProps()
        - 지금은 사라진 componentWillReceiveProps를 대체할 수 있는 메서드로 render()를 호출하기 직전에 호출된다. static으로 선언돼 this에 접근할 수 없다.
    - getSnapShotBeforeUpdate()
        - componentWillUpdate를 대체할 수 있는 메서드로 DOM이 업데이트되기 직전에 호출되어 반환되는 값은 componentDidUpdate로 전달된다.
        - DOM에 렌더링되기 전에 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 등의 작업을 처리하는데 유용하다.
    
    ![image.png](2%E1%84%8C%E1%85%A1%E1%86%BC%20205f78a2bff180de9272f4cd5cf55fc4/image.png)
    

- 클래스 컴포넌트의 한계
    - 데이터의 흐름을 추적하기 어렵다.
    - 애플리케이션 내부 로직의 재사용이 어렵다.
    - 기능이 많아질수록 컴포넌트의 크기가 커진다.
    - 클래스는 함수에 비해 상대적으로 어렵다.
    - 코드 크기를 최적화하기 어렵다.
    - 핫 리로딩을 하는데 상대적으로 불리하다.
- 함수 컴포넌트 vs 클래스 컴포넌트
    - 생명주기 메서드의 부재
        - 함수 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수라서 클래스 컴포넌트의 생명주기 메서드가 존재하지 않는다.
        - 허나 함수 컴포넌트는 useEffect 훅을 사용해서 생명주기 메서드를 비슷하게 구현할 수 있다.
    - 함수 컴포넌트와 렌더링된 값
        - 함수 컴포넌트는 렌더링된 값을 고정하고, 클래스 컴포넌트는 그렇지 못하다.
        - 함수 컴포넌트는 렌더링이 일어날때 마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. props와 state가 변경된다면 다시 그 값을 기준으로 함수가 호출된다.
        - 반면 클래스 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.

## 2.4 렌더링은 어떻게 일어나는가?

- 리액트의 렌더링 : 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정
- 리액트의 렌더링이 일어나는 경우
    - 최초 렌더링 (처음 애플리케이션 진입)
    - 리렌더링
        - 클래스 컴포넌트의 setState나 forceUpdate가 실행되는 경우
        - 함수 컴포넌트의 useState()의 두번째 배열요소인 setter가 실행되는 경우
        - 함수 컴포넌트의 useReducer()의 두번째 배열요소인 dispatch가 실행되는 경우
        - 컴포넌트의 key props가 변경되는 경우
        - props가 변경되는 경우
        - 부모 컴포넌트가 변경되는 경우
- 렌더 단계
    - 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
    - 렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다.
- 커밋 단계
    - 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
- **리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.** 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없는 경우 생략될 수 있기 때문이다.

![image.png](2%E1%84%8C%E1%85%A1%E1%86%BC%20205f78a2bff180de9272f4cd5cf55fc4/image%201.png)

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

- 메모이제이션 최적화에 대한 주장은 2가지로 나뉜다.
- 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자
    - 메모이제이션도 비용이 드는 작업으로 최적화에 대한 비용을 지불할 때는 항상 신중해야 한다.
    - 메모이제이션 또한 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두가지 비용이 있다. 이 비용이 때로는 리렌더링 비용보다 더 나갈 수 도 있다.
    - 메모이제이션을 통한 성능 개선이 렌덜이보다 낫지 않다면 결국 안하느니만 못하는 상황이 될 수 도 있다.
    - 또한 useMemo는 성능 최적화를 위해 사용될 수 있지만 캐시 결과가 영원히 유지되는 것은 아니다. 어떤 경우에 따라 캐시가 무효화되는 경우가 있을 수도 있다.
- 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션하자.
    - 이 주장과 위의 주장의 공통점은 일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다는 것이다.
    - 잘못된 memo로 지불해야하는 비용은 prop에 대한 얕은 비교가 발생하면서 지불해야하는 비용이다.
    - 허나 memo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같다.
        - 렌더링을 함으로서 발생하는 비용
        - 컴포넌트 내부의 복잡한 로직의 재실행
        - 위의 2가지가 모든 자식 컴포넌트에서 반복해서 일어남
        - 리액트가 구 트리와 신규 트리를 비교
    - 따라서 메모이제이션을 하지 않는 것보다 메모이제이션을 했을 때 더 많은 이점을 누릴 수 있다.