- SSR 에 대해 알아보자.
- 기존에는 CRA 가 각광받았지만 요즘은 Next.js 같은 프레임워크를 사용해 프로젝트를 만드는 것이 큰 인기를 끌고 있다.

# 4.1 서버 사이드 렌더링이란?

---

### 4.1.1 싱글 페이지 애플리케이션의 세상

**1️⃣ 싱글 페이지 애플리케이션이란?**

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식을 의미한다.
- 하나의 페이지에서 모든 작업 처리
- 최초에 서버에서 최소한의 데이터를 불러온 이후부터는 이미 가지고 있는 자바스크립트 리소스와 브라우저 API 를 기반으로 모든 작동이 이뤄진다.
- 리소스가 커지나, 훌륭한 UI/UX 제공

**2️⃣ 전통적인 방식의 애플리케이션과 SPA 작동 비교**

- 전통적인 방식은 페이지 전환을 HTML 을 만들어서 제공해야 하기 때문에 처음부터 다시 만들어지는 것처럼 보이지만, 자바스크립트로 한다면 추가 리소스 다운 받을 시간도 일부만 렌더링시킬 수 있으므로 더욱 매끄러운 UI 를 보여줄 수 있다.

**3️⃣ 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장**

- php 난 jsp 모두 대부분 서버 사이드 렌더링임.
- **❗원래 페이지 이동은 새로운 페이지를 서버에서 내려받는 방식이었고, 자바스크립트는 어디까지나 사용자에게 추가적인 경험을 주기 위한 보조적인 수단으로 사용됐다.**
- 그러나 자바스크립트가 서서히 다양한 작업을 수행하게 되면서 자바스크립트 모듈화하는 방식인 commonJs 와 AMD 가 등장하고, 기기 성능 향상 인터넷 속도 발전 등으로 자바스크립트에서 할 수 있는 일이 점차 다양해졌다.
- 그러다 2010 년 경 backbone.js 와 AngularJS, Knockout.js 등이 등장하면서 자바스크립트 수준에서 MVx 프레임워크를 구현하기 시작했다.
- 그러다 React, Vue, Angular 의 시대가 오고, 자바스크립트가 없으면 보여줄 수 없을 정도로 자바스크립트의 역할에 크게 의존하고 있다.
- **JAM 스택!**
- 기존 웹은 LAMP 스택 (Linux, Apache, MySQL, PHP/Pyhon 으로 구성되어 있었다.
- 자바스크립트가 할 수 있는 일이 제한적이었기 때문에 대부분의 처리를 서버에서 해야 했는데, 이러한 문제는 웹 애플리케이션의 확장성에도 걸림돌로 작용했다. → 기능이 다양해지거나 사용자가 늘어나면 동시에 서버를 확장해야 했는데, 예전에는 클라우드 관련 개념이 부족했기에 서버를 확장하는 것은 매우 번거로웠다.
- JAM (Javascript, API, Markup) 스택 → 서버 확장성 문제로부터 자유로워질 수 있었음.
- 이제 Node.js 의 고도화에 힘입어 MEAN 이나 MERN 스택처럼 API 서버 자체도 자바스크립트로 구현하는 구조가 인기를 끌게 되었다.
  ![image.png](attachment:d8e5b564-b145-4844-ab76-3566dfaaee6a:image.png)

**4️⃣ 새로운 패러다임의 웹서비스를 향한 요구**

- 많은 양의 리소스가 자바스크립트로 넘어오기 시작하던 때, 자바스크립트 코드의 규모도 점차 커지면서 이에 대해 우려의 목소리도 조금씩 나오기 시작했다. 폭발적인 기술의 발전으로 쉽게 해결될 것이라 기대했지만…..
  ![image.png](attachment:fcbf7dc0-c64c-4b9c-9c2e-0d72965211ca:image.png)

![image.png](attachment:e431914a-b22f-4905-8044-4b3c46cb7528:image.png)

- 그렇다면 웹 페이지 속도는 얼마나 개선됐을까? 효과적으로 처리할 수 있을가?
  ![image.png](attachment:d59ae26f-f396-40b9-958a-e70d39d24468:image.png)
  ![image.png](attachment:034749cf-8625-4942-a1fe-ee439de53ef7:image.png)
  ![image.png](attachment:15907914-415f-4e1d-aa40-54054e801bbb:image.png)
- 자바스크립트 파싱을 위해 CPU를 소비하는 시간이 눈에 띄게 증가했다. 자바스크립트에서 처리해야 하는 코드의 양이 절대적으로 증가했다는 것을 알 수 있다.
  ![image.png](attachment:d03b9044-62ae-4aed-b96f-afeda3e763c8:image.png)
- 이러한 환경에서 웹 서비스 환경에 대해서 고민할 필요가 있었다.

### 4.1.2 서버 사이드 렌더링이란?

- 서버에서 렌더링해 빠르게 사용자에게 화면을 렌더링하는 방식이다.
  ![image.png](attachment:8ae5a5ed-9703-472d-ab24-2f07a5d3d4ea:image.png)
- 웹 페이지의 렌더링 책임을 어디에 두느냐가 차이다.

**1️⃣ 서버 사이드 렌더링 장점**

- 최초 페이지 진입이 비교적 빠르다.
- 검색 엔진과 SNS 공유 등 메타 데이터 제공이 쉽다.
- 누적 레이아웃 이동 (layout shift)를 줄일 수 있다. → 서버 사이드에서도 완전히 자유로울 수 없는 것이 useEffect 는 클라이언틍서 마운트될 이후에 실행되기 때문이다.
- 사용자의 디바이스 성능에 비교적 자유롭다. → 물론 서버 부담이 증가한다면…
- 보안에 좀 더 안전하다. → JAM 은 모든 브라우저 환경이 노출된다. 민감한 작업을 서버에서 수행하고 브라우저에 제공해 보안 위협을 피할 수 있다.

**2️⃣ 단점**

- 소스코드를 작성할 때 항상 서버를 고려해야 한다. → 전역 객체 window 와 웹 스토리지는 브라우저에만 존재하는 전역 객체이다. 이를 고려해 코드를 작성해야 하고, 라이브러리가 서버에 대한 고려가 되어 있지 않으면 클라이언트에서만 실행할 수 있다. → 그렇다고 전부 클라이언트로 하면, 서버 사이드 렌더링의 장점을 잃는 셈.
- 적절한 서버가 구축돼 있어야 한다. → 서버에서 렌더링을 수행할 수 있어야 함.
- 서비스 지연에 따른 문제 → 서버에서 사용자에게 보여줄 페이지에 대한 렌더링 작업이 끝나기까지는 사용자에게 그 어떤 정보도 제공할 수 없다.

### 4.1.3 SPA 와 SSR 를 모두 알아야 하는 이유

**1️⃣ 서버 사이드 렌더링 역시 만능이 아니다.**

- 무거운 작업을 서버로 미루는 것이 관리 포인트만 늘어나는 역효과를 낳을 수도 있다.
- 만병통치약이 아님을 알아야 한다.

**2️⃣ 싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션**

- 다음과 같다고 한다.
  ![image.png](attachment:de7b6138-4139-4d04-ae4c-63ffcc8fb69d:image.png)
- 결국 둘 다 유효하다는 것을 이해해야 한다.
- 은탄환은 없다!

**3️⃣ 현대의 서버 사이드 렌더링**

- 기존의 LAMP 스택에서 표현했던 서버 사이드 렌더링 방식과는 조금 다르다.
- 초기 페이지 진입이 빠르다는 장점이 있지만 라우팅할 때마다 서버에 의존하기 때문에 페이지 진입이 느리다는 단점이 있다.
- 그래서 요즘에는 최초 진입 시에는 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML 을 제공받고 이후 라우팅에서는 서버에서 내려온 자바스크립트를 바탕으로 SPA 처럼 동작한다.

### 4.1.4 정리

- 둘 다의 장단점이 있으므로 숙지하고 사용 방법을 알아야 한다.

# 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

---

- 리액트는 기본적으로 CSR 을 제공하지만 서버에서 렌더링할 수 있는 API 도 제공한다.
- ⚠️ 당연히 window 환경이 아닌 Node.js 와 같은 서버 환경에서만 실행할 수 있으며 window 환경에서 실행 시 에러가 발생할 수 있다.

### 4.2.1 renderTostring

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
- 서버 사이드 렌더링을 구현하는 데 가장 기초적인 API 임.
  ![image.png](attachment:8d5f4ecb-75b4-4a81-a50f-819808df0b06:image.png)
- 위 result 는 다음과 같은 문자열을 반환한다.
  ![image.png](attachment:0403a654-3d92-4d68-a262-e93356d36084:image.png)
- **🌟결과물에 useEffect 와 같은 훅이나 이벤트 핸들러는 결과에 포함되지 않았다는 점에 눈여겨 보아라**
- renderToString은 인수로 주어진 리액트 컴포넌트를 기준으로 빠르게 렌더링할 수 있는 HTML 을 제공하는 것이 목적인 함수이기 때문. → ❗따라서 필요한 자바스크립트 코드는 HTML 코드와는 별로도 제공해주어야 한다.
- 또 주목해야 할 부분은 div #root 의 data-reactroot 이다. 이건 리액트 컴포넌트의 루트 엘리먼트를 식별하는 역할을 하며, hydrate 함수에서 루트를 식별하는 기준점이 된다.

### 4.2.2 renderToStaticMarkup

- renderToString 과 유사한 함수로 HTML 문자열을 만든다는 점에서 동일하다.
- 유의미한 차이점은 data-reactroot 와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지는 않는다는 점이다. → 덕분에 HTML 의 크기를 아주 약간이라도 줄일 수 있다.
  ![image.png](attachment:a5cb2cd3-3b8d-4b26-96f2-2b1694cb6f75:image.png)
- **이 함수를 실행한 결과로 렌더링을 수행하면 클라이언트에서는 리액트에서 제공하는 useEffect 와 같은 브라우저 API 를 절대로 수행할 수 없다.**
- 따라서 이벤트 리스너가 필요 없는 완전히 순수한 HTML 을 만들 때만 사용된다. 브라우저 액션이 없는 정적인 내용만 필요한 경우에 유효하다.

### 4.2.3 renderToNodeStream

- renderToString 과 결과물은 완전히 동일하지만 두 가지 차이점이 있다.
- **첫번째, renderToString 과 renderToStaticMarkup 은 브라우저에서도 실행할 수 있지만, 이건 사용하는 것이 완전히 불가능 하다. → 애초에 실행할 이유도 없지만 완전히 Node.js 환경에 의존한다는 사실을 기억하자.**
- **두 번째, 결과물의 타입이다. renderToString 은 string 문자열이지만, renderToNodeStream 의 결과물은 Node.js 의 ReadableStream 이다. utf-8로 인코딩된 바이트 스트림으로 Node.js 와 같은 서버 환경에서만 사용 가능하다. string 을 얻기 위해서는 추가적인 처리가 필요하다.**
- ReadableStream 은 브라우에서도 사용할 수 있는 객체이지만, 만드는 과정이 브라우저에서 불가능하게 구현돼 있다.
- 먼저 스트림이란 한 번에 보내는 것이 아닌 데이터를 청크(chunk)로 분할해 조금씩 가져오는 방식을 의미한다.
- renderToString 으로 생성해야 하는 HTML 의 크기가 매우 크면 한 번에 메모리에 올려두고 응답을 수행해야 해서 Node.js 가 실행되는 서버에 큰 부담이 될 수 있다. 대신 스트림을 활용하면 청크 단위로 분리해 순차적으로 처리할 수 있다는 장점이 된다.
- 응답으로 HTML 이 청크로 분리돼 내려오는 것을 확인할 수 있다.
- renderToString 을 상요하면 거대한 HTML 파일이 완성될 때까지 기다려야 겠지만, 스트림을 활용하여 작은 단위로 쪼개 Node.js 서버 부담을 줄일 수 있다.
- 대부분 리액트 SSR 프레임 워크는 renderToNodeStream 을 채택하고 있다.

### 4.2.4 renderToStaticNodeStream

- renderToString 과 renderToStaticMarkup 의 관계처럼 renderToNodeStream 과 renderToStaticNodeStream 이 관계가 그렇다.
- 리액트 속성이 제공되지 않고 순수 HTML 결과물이 필요할 때 사용

### 4.2.5 hydrate

- HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
- hydrate 에 앞서 브라우저에서만 사용되는 render 를 살펴보자.
  ![image.png](attachment:07e75e4e-4166-4040-be9f-1d60087c4dee:image.png)
- 컴포넌트와 HTML 의 요소를 인수로 받는다.
- 인수로 받은 두 정보를 바탕으로 HTML 요소에 해당 컴포넌트를 렌더링하며 여기에 이벤트 핸들러를 붙이는 작업까지 모두 한 번에 수행한다.
- hydrate 를 살펴보자.
- 인수를 넘기는 것이 거의 유사하다.
  ![image.png](attachment:cef6db42-29e3-4aa0-b3af-c3ccc08b8b57:image.png)
- render 와의 차이점은 hydrate 는 기본적으로 이미 렌더링된 HTML 이 있다는 가정 하에 작업을 수행하고 이벤트만 붙이는 작업을 실행하는 것이다.
- 따라서 만약 hydrate 의 두 번째 인수로 renderToStaticMarkup 등으로 생성된, 리액트 관련 정보가 없는 순수한 HTML 정보를 넘겨주면 어떻게 될까?
  ![image.png](attachment:044caf16-41d2-4011-96d3-04ff9e0e227c:image.png)
- span 요소를 기대했지만 없다고 경고를 띄운다.
- rootElement 에는 꼭 renderToString 등으로 렌더링된 정적인 HTML 정보가 반드시 담겨 있어야 한다. 아무것도 없는 빈 HTML 에 정보를 렌더링하는 render 와의 차이점이 바로 이것이다.
- **❗경고가 발생했음에도 정상적으로 웹 페이지를 만드는 것을 볼 수 있는데, 이것은 hydrate가 이벤트나 핸드러를 추가하는 것 이외에도 렌더링을 한 번 수행하면서 결과물 HTML 인수로 넘겨받은 HTML 을 비교하는 작업을 수행하기 때문이다.→ 불일치가 에러의 원인이고 불일치가 발생하면 hydrate 가 웹 페이지를 그리게 된다. 올바른 방법은 아니긴 하다. 서버와 클라이언트 두 번 렌더링을 하게되고 결국 서버 사이드 렌더링의 장점을 포기하는 것이기 때문이다.**
- 하지만 초 단위까지 기록하는 것을 사용한다면 빨리 hydrate 를 하더라도 불일치가 발생하고 에러를 발생시킬 수 있다.
  ![image.png](attachment:b8d2331b-012b-4e36-b919-5941e930f17d:image.png)
- 이럴 때는 supperessHydrationWaring 을 추가해 경고를 끌 수 있다. 다만 제한적으로 사용해야 한다.
- 차라리 useEffect 를 통해 시간만 노출하는 것이 서버에서 굳이 실행도 안시키니 경우에 따라 좋을 수도 있다.

### 4.2.6 서버 사이드 렌더링 예제 프로젝트

### 4.2.7 정리

- SSR 을 개발자 개인이 작성하는 것은 매우 비효율적이다.
- SSR 의 장점 이면에는 개발자에게 많은 부담이 된다. → 개발자들에게 큰 도전
