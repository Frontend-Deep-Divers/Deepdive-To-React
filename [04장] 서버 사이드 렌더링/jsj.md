# 4장 서버 사이드 렌더링

## 4.1 서버 사이드 렌더링이란?

- 싱글 페이지 애플리케이션 (SPA)
    - 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식
    - 최초에 첫 페이지에서 데이터를 모두 불러온 후 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 history.pushState와 history.replaceState로 이뤄지기 때문에 페이지를 불러운 이후에는 서버에서 HTML을 내려받지 않고 하나의 페이지에서 모든 작업을 처리한다.
    - 사이트 렌더링에 필요한 <body/> 내부의 내용을 모두 자바스크립트 코드로 삽입한 이후에 렌더링한다.
    - 또한 페이지 전환시에도 새로운 HTML 페이지를 요청하는 것이 아닌 자바스크립트에서 다음 페이지의 렌더링에 필요한 정보만 HTTP 요청으로 가져와 그 결과를 바탕으로 <body/>내부에 DOM을 수정하는 방식으로 페이지가 전환된다.
    - 최초에 로딩해야할 자바스크립트 리소스가 커지지만 한번 로딩된 이후에는 서버를 거쳐 필요한 리소스를 받아올 일이 적어져 UI/UX 경험이 좋다는 장점이 있다.
    - 전통적인 방식의 애플리케이션의 경우 페이지 전환시 새로운 HTML 페이지를 요청하고 새로 그리는 작업을 통해 페이지 전환시 부자연스러운 모습을 보이지만, 페이지 전환을 모두 자바스크립트로 하게 되면 최초에 한번 모든 리소스를 다운로드하고 나면 이후 페이지를 전환할 때 추가로 리소스를 다운로드 하는 시간이 필요 없어지고 더 매끄러운 UI를 보여줄 수 있게 된다.
- 처음에는 웹 어플리케이션에서 자바스크립트는 보조적인 수단으로 사용되었고, 대부분의 페이지들은 서버 사이드에서 렌더링되었다. 허나 자바 스크립트가 모듈화 되고 사용자 기기의 성능 향상과 인터넷 속도의 발전 등으로 자바 스크립트에서 할 수 있는 일이 점차 다양해졌다.
- MVx 프레임워크가 구현되면서 자바스크립트에서도 어느 정도 서버가 하던 복잡한 작업을 할 수 있게 되었고, 이로 인해 자바스크립트의 역할과 규모가 점점 커져갔다. 자바 스크립트의 역할에 많은걸 의존하게 되면서, 웹 페이지의 모든 영역을 담당하고 아우를 수 있는 방식 + 브라우저 내부에서 작동하는 자바스크립트만 잘 작성하면 되는 싱글 페이지 애플리케이션이 인기를 끌게 되었다.
- JAM 스택 (JavaScript, API, Markup)
    - 웹 개발 구조로, 자바 스크립트와 마크업(HTML, CSS)을 미리 빌드해두고 정적으로 사용자에게 제공하면 이후 작동은 모두 사용자의 클라이언트에서 실행되므로 서버 확장성 문제에서 좀 더 자유로워질 수 있었다.
- MERN 스택 (MongoDB, Express.js, React, Node.js)
    - API 서버 자체도 자바스크립트로 구현하는 구조
- 인터넷 속도와 하드웨어 성능이 굉장히 높아졌지만, 많은 양의 리소스가 자바스크립트로 넘어오게 되면서 결국 웹 어플리케이션에서 제공하는 자바스크립트 리소스의 크기와 수가 모두 증가하기 시작했다.. 결국 이는 웹 애플리케이션의 로딩속도, 특히 모바일 환경에서는 몇년전이나 지금이나 속도가 크게 차이나지 않는 결과를 낳아버렸다.
- 서버 사이드 렌더링
    - 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식
    - 장점
        - **최초 페이지 진입이 비교적 빠르다.**
            - 모든 경우는 아니지만 일반적인 가정하에, 최초에 사용자에게 보여줘야할 화면이 외부 API 호출에 많이 의지하는 경우나 렌더링할 HTML의 크기가 큰 경우, 서버에서 HTML을 그리는 속도가 클라이언트에서 하는것보다 속도가 더 빠르다.
        - **검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.**
            - 검색 엔진이 사이트에서 정보를 가져가는 과정
                - 검색 엔진 머신이 페이지에 진입한다.
                - 페이지가 HTML 정보를 제공해 머신이 이 HTML을 다운로드한다. (자바 스크립트 코드는 실행하지 않음)
                - 다운로드한 HTML 페이지 내부의 오픈 그래프나 메타 태그 정보를 기반으로 페이지의 검색 정보를 가져오고 이를 바탕으로 검색 엔진에 저장한다.
            - 검색 엔진 머신은 페이지의 정적인 정보를 가져오는 것이 목적이므로 자바스크립트를 실행하지 않는데, 싱글 페이지 애플리케이션의 경우 대부분의 작동이 자바스크립트에 의존한다. (메타 데이터도 마찬가지) 따라서 검색 엔진이 최초에 방문했을 때 메타 정보를 제공할 수 있도록 조치를 취하지 않으면 불이익이 있을 수 있다.
            - 허나 서버 사이드 렌더링의 경우 최초 렌더링 작업이 서버에서 일어나므로 검색 엔진에 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공할 수 있으므로 검색 엔진 최적화에 대응하기 용이하다.
        - **누적 레이아웃 이동이 적다.**
            - 누적 레이아웃 이동 : 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥 거리는것 같은 부정적인 사용자 경험
            - 서버 사이드 렌더링의 경우 요청이 완전히 완료된 이후에 완성된 페이지를 제공하므로 이러한 문제에서 비교적 자유롭다. (허나 완전히 자유롭지는 않다..)
        - **사용자의 디바이스 성능에 비교적 자유롭다.**
            - 자바스크립트 리소스는 사용자의 디바이스에서만 실행되므로 사용자 디바이스 성능에 의존적이나 서버 사이드 렌더링은 부담을 서버에 나눌 수 있다.
        - **보안에 좀 더 안전하다.**
            - JAM 스택을 채택한 프로젝트들의 경우 애플리케이션의 모든 활동이 브라우저에 노출(개발자 도구)된다. 허나 서버 사이드 렌더링의 경우 인증이나 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 보안 위협을 피할 수 있다.
    - 단점
        - 소스코드를 작성할 때 항상 서버를 고려해야 한다.
            - 브라우저 전역 객체인 window나 브라우저에만 있는 전역 객체인 sessionStorage의 경우 서버에서 실행이 불가능하며 이런 코드를 사용하는 라이브러리 또한 적절한 대안을 처리해야한다.
        - 적절한 서버가 구축돼 있어야 한다.
            - 사용자의 요청에 따라 적절하게 대응할 수 있는 물리적인 가용량 확보 및 장애 상황에 대응할 수 있는 복구 전략 등등 서버를 구축하는 것은 항상 어려운 일이다..
        - 서비스 지연에 따른 문제
            - 지연 작업이 최초 렌더링에 발생해버린다면 해당 작업이 끝나기 전까지 사용자에게 아무런 정보도 제공할 수 없어 더 안좋은 사용자 경험을 제공할 수도 있다.
- 가장 뛰어난 SPA는 가장 뛰어난 멀티 페이지 애플리케이션(SSR 방식)보다 낫지만 이는 이론적인 예시고, 평균적인 SPA는 평균적인 멀티 페이지 애플리케이션보다 느리다. 이는 서버는 매 요청마다 비슷한 성능의 렌더링을 수행하지만, 일반적인 SPA의 경우 사용자 기기에 따라 성능이 들쑥날쑥하고, 적절한 성능 최적화 또한 되어있지 않을 가능성이 높기 때문이다.
- 현대의 서버 사이드 렌더링
    - 기존의 LAMP 스택 (Linux(운영체제), Apache(서버), MySQL(데이터베이스), PHP/Python등(웹 프레임워크)의 경우 모든 페이지 빌드를 서버에서 렌더링해 초기 페이지 진입이 빠르다는 장점이 있지만, 라우팅이 발생할 때도 서버에 의존해야 하므로 싱글 페이지 렌더링 방식에 비해 라우팅이 느리다.
    - 요즘의 경우, 최초 웹사이트 진입시에는 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 SPA처럼 작동한다.

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

- 이들은 Node.js 와 같은 서버 환경에서만 실행될 수 있다.
- **renderToString**
    - 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수다.
    - 서버 사이드 렌더링을 구현하는 데 가장 기초적인 API로, 최초의 페이지를 HTML로 먼저 렌더링할때의 역할을 한다.
    - 이벤트 핸들러 같은 클라이언트에서 실행되는 자바스크립트 코드를 포함시키거나 렌더링하는 역할까지는 하지 않는다.
    - **단순히 최초 HTML 페이지를 빠르게 그려주는 데** 목적이 있으며 웹 페이지가 사용자와 인터랙션하려면 이와 관련된 별도의 자바스크립트 코드를 모두 다운로드 파싱, 실행하는 과정을 거쳐야 한다.
    - data-reactroot : div#root에 존재하는 속성으로 이 속성은 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별하는 역할을 한다. 이후 자바스크립트를 실행하기 위한 hydrate 함수에서 루트를 식별하는 기준점이 된다.
- renderToStaticMarkup
    - renderToString 처럼 리액트 컴포넌트를 기준으로 HTML 문자열을 만들지만 data-reactroot처럼 리액트에서만 사용하는 추가적인 DOM 속성을 만들지은 않는다.
    - 순수한 HTML 문자열을 반환하며 HTML의 크기를 아주 약간이라도 줄일 수 있다.
    - 아무런 브라우저 액션이 없는 정적인 내용만 만들때 유용하다.
- renderToNodeStream
    - renderToString과 결과물이 동일하지만 두가지 차이점이 있다.
        - 앞의 두 API는 브라우저에서도 실행할 수 있지만 renderToNodeStream은 브라우저에서 사용하는 것이 완전히 불가능하다.
        - 결과물이 Node.js의 ReadableStream으로 utf-8로 인코딩된 바이트 스트림으로 Node.js 같은 서버 환경에서만 사용할 수 있다. 브라우저가 원하는 결과물, string을 얻기 위해서는 추가적인 처리가 필요하다.
    - renderToString으로 생성해야 하는 HTML의 결과물의 크기가 매우 큰 경우, 크기가 큰 문자열을 한번에 메모리에 올려두고 응답을 수행해야 해서 서버에 큰 부담이 될 수 있다.
    - 허나 스트림을 활용하면 이런 큰 크기의 데이터를 청크 단위로 분리해 순차적으로 처리할 수 있다.
- renderToStaticNodeStream
    - renderToNodeStream과 제공하는 결과물은 동일하나 리액트 자바스크립트에 필요한 리액트 속성이 제공되지 않는다. hydrate를 할 필요 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드다.
- hydrate
    - renderToString과 renderToNodeStream으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
    - hydrate는 render와 인수를 넘긴다.
        - render함수 : 컴포넌트와 HTML의 요소를 인수로 받아 이 정보를 바탕으로 HTML의 요소에 해당 컴포넌트를 렌더링하며, 이벤트 핸들러를 붙이는 작업까지 모두 한번에 수행한다.
    - render와의 차이
        - hydrate는 기본적으로 렌더링된 HTML이 있다는 가정하에 작업이 수행되며 이미 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 실행한다.
        - 허나 리액트 관련 정보가 없는 순수한 HTML 정보를 넘겨주면 (렌더링된 HTML요소가 없는 경우) 경고를 출력하지만, 웹페이지는 정상적으로 생기긴한다. 이는 hydrate의 작업이 단순 이벤트를 추가하는 것 외에도 렌더링을 한번 수행하면서 수행한 렌더링 결과물 HTML과 인수로 넘겨받은 HTML을 비교하는 작업을 진행하기 때문이다. 여기서 불일치가 발생하면 경고를 내고, hydrate가 렌더링한 기준으로 웹페이지를 그리게 된다.
        - 하지만 이렇게 렌더링되는 건 결국 서버, 클라이언트 두군데서 렌더링하는 꼴이기에 문제가 있다..